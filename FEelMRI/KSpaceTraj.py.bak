import matplotlib.pyplot as plt
import numpy as np
from scipy.interpolate import interp1d

from FEelMRI.Math import divide_no_nan
from FEelMRI.MPIUtilities import scatterKspace, MPI_rank
import warnings

# plt.rcParams['text.usetex'] = True

# Gradient
class Gradient:
  def __init__(self, slope=None, lenc=1.0, G=None, Gr_max=30.0, Gr_sr=195.0, gammabar=42.58, t_ref=0.0):
    self.Gr_max  = Gr_max        # [mT/m]
    self._Gr_max = 1.0e-3*Gr_max # [T/m]
    self.Gr_sr  = Gr_sr          # [mT/(m*ms)]
    self._Gr_sr = Gr_sr          # [T/(m*s)]
    if G is None:
      self.G = self.Gr_max       # [mT/m]
    else:
      self.G = G                 # [mT/m]
    self._G = 1.0e-3*self.G      # [T/m]
    self.lenc = lenc     # [ms]
    self._lenc = 1.0e-3*lenc     # [s]
    if slope is None:
      self.slope = np.abs(self.G)/self.Gr_sr # [ms]
    else:
      self.slope = slope   # [ms]
    self._slope = 1.0e-3*self.slope        # [s]
    self.gammabar = gammabar               # [MHz/T]
    self._gammabar = 1.0e+6*gammabar       # [Hz/T]
    self._gamma = 2.0*np.pi*1e+6*gammabar  # [rad/T]
    self.t_ref = t_ref                     # [ms]
    self.timings, self.amplitudes, self.interpolator = self.group_timings()

  def __add__(self, g):
    # Concatenate gradients
    return 1

  def evaluate(self, t):
    """
    Evaluate the interpolator at a given time point.

    Parameters:
    t (float): The time point at which to evaluate the interpolator.

    Returns:
    float: The interpolated value at the given time point.
    """
    return self.interpolator(t)

  def group_timings(self):
    """
    Groups the timing and amplitude values for gradient evaluation based on the 
    length of the encoding (lenc) and slope parameters.

    If `self.lenc` is less than or equal to 0.0, the timings and amplitudes are 
    calculated for a simple slope. Otherwise, they are calculated for a slope 
    with an encoding length.

    Timings and amplitudes are adjusted by the reference time (`self.t_ref`).

    Returns:
      tuple: A tuple containing:
        - timings (np.ndarray): Array of timing values.
        - amplitudes (np.ndarray): Array of amplitude values.
        - interp (interp1d): Interpolator for gradient evaluation.
    """
    if self.lenc <= 0.0:
      timings = np.array([0.0, 
                          self.slope,
                          self.slope+self.slope])
      amplitudes = np.array([0.0, 
                            self.G,
                            0.0])
    else:
      timings = np.array([0.0, 
                          self.slope, 
                          self.slope+self.lenc, 
                          self.slope+self.lenc+self.slope])
      amplitudes = np.array([0.0, 
                            self.G, 
                            self.G, 
                            0.0])

    # Add reference time
    timings += self.t_ref

    # Define interpolator for gradient evaluation
    interp = interp1d(timings, amplitudes, kind='linear', fill_value=0.0, bounds_error=False)

    return timings, amplitudes, interp

  def calculate(self, bw_hz, receiver_bw=None, ro_samples=None, ofac=None):
    """
    Calculate gradient based on slope, slew rate, and amplitude parameters.

    Parameters:
    -----------
    bw_hz : float
      Bandwidth in Hz.
    receiver_bw : float, optional
      Receiver bandwidth in Hz. If provided, lenc is fixed and calculated accordingly.
    ro_samples : int, optional
      Number of readout samples.
    ofac : float, optional
      Oversampling factor.

    Returns:
    --------
    None

    Notes:
    ------
    This method calculates the gradient parameters including slope, gradient amplitude (G),
    and length (lenc) based on the provided bandwidth and optional receiver bandwidth.
    If the receiver bandwidth is provided, the length is fixed and calculated accordingly.
    Otherwise, the method calculates the parameters assuming only the ramps are needed.

    The calculated parameters are stored in the instance variables:
    - self.lenc : Length in ms
    - self.G : Gradient amplitude in mT/m
    - self.slope : Slope in ms
    - self.dur : Duration in ms

                                             __________
                _1_ /|\                    /|          |\
     slew rate |  /  |  \                /  |          |  \
               |/    G    \            /    G          G    \
              /      |      \        /      |          |      \
               slope   slope          slope     lenc     slope

    The method also updates the timings and amplitudes arrays using the group_timings method.
    """

    # Calculate gradient
    if receiver_bw is not None:
      ''' If the receiver bandwidth is given, the lenc should be fixed and
      calculated accordingly
      '''
      self._lenc  = (ro_samples/ofac)/receiver_bw       # [s]
      self._G     = bw_hz/(self._gammabar*self._lenc)   # [T/m]
      if self._G > self._Gr_max:
        self._G = self._Gr_max
        self._lenc = bw_hz/(self._gammabar*self._G)
        receiver_bw  = (ro_samples/ofac)/self._lenc     # [Hz]
        if MPI_rank == 0:
          warnings.warn("The required gradient amplitude exceeds the maximum allowed. Adjusting to maximum gradient amplitude. Receiver bandwidth allowed with current configuration is {:.0f} Hz".format(receiver_bw))
      self._slope = np.abs(self._G)/self._Gr_sr # [s]
    else:
      ''' Calcualte everything as if only the ramps are needed '''
      # Time needed to reach the maximun amplitude
      slope_req_ = np.sqrt(np.abs(bw_hz)/(self._gammabar*self._Gr_sr)) # [s]

      # Time needed for the maximun amplitude
      slope_ = self._Gr_max/self._Gr_sr # [s]

      # Build gradient
      if slope_req_ < slope_:
        self._slope = slope_req_                # [s]
        self._G     = self._Gr_sr*slope_req_    # [T/m]
        self._lenc  = self._slope - slope_req_  # [s]
      else:
        # Assign slope and gradient amplitude
        self._slope  = slope_            # [s]
        self._G      = self._Gr_max # [T/m]

        # Calculate lenc
        bw_hz_slopes_ = self._gammabar*self._Gr_sr*slope_**2
        self._lenc    = (np.abs(bw_hz) - bw_hz_slopes_)/(self._G*self._gammabar)

      # Account for area sign
      self._G *= np.sign(bw_hz)

    # Store variables in mT - ms
    self.lenc  = 1.0e+3*self._lenc    # [ms]
    self.G     = 1.0e+3*self._G       # [mT/m]
    self.slope = 1.0e+3*self._slope   # [ms]
    if self.lenc < 0:
      self.dur_ = self._slope + self._slope # [ms]
    else:
      self.dur_ = self._slope + self._lenc + self._slope # [ms]
    self.dur = 1.0e+3*self.dur_ # [s]

    # Update timings and amplitudes in array
    self.timings, self.amplitudes, self.interpolator = self.group_timings()

  def make_bipolar(self, VENC):
    ''' Calculate the time needed to apply the velocity encoding gradients
    based on the values of Gr_max and Gr_sr'''

    # Just use minimun VENC in case VENC is an array
    VENC = np.min(VENC)

    # Bipolar lobes areas without rectangle part
    # If lenc = 0, 2*pi = gamma*G(t)*VENC*slope^2
    # which is equivalent to: 2*pi = gamma*SR*VENC*slope^3
    slope_ = self._Gr_max/self._Gr_sr # [s]
    slope_req_ = np.cbrt(np.pi/(2*self._gamma*VENC*self._Gr_sr))

    # Check if rectangle parts of the gradient are needed
    if slope_req_ <= slope_:
      # Calculate duration of the first velocity encoding gradient lobe
      self._slope = slope_req_                # [s]
      self._G     = self._Gr_sr*slope_req_    # [s]
      self._lenc  = self._slope - slope_req_  # [s]
    else:
      # Lobe area (only ramps)
      area_ramps = slope_*self._Gr_max

      # Estimate remaining area 
      # If lenc != 0:
      #     pi = gamma*Gmax*VENC*(lenc + slope)*(lenc + 2*slope)
      # which is equivalent to
      #     pi = gamma*VENC*(Gmax*lenc + Ar)*(lenc + 2*slope)
      a = self._Gr_max
      b = area_ramps + 2*slope_*self._Gr_max
      c = (2*slope_*area_ramps - np.pi/(self._gamma*VENC))
      t2 = np.array([(-b + np.sqrt(b**2 - 4*a*c))/(2*a),
                     (-b - np.sqrt(b**2 - 4*a*c))/(2*a)])

      # Remove negative solutions
      t2[t2 < 0] = 1e+10
      t2 = t2.min()

      # Gradients parameters
      self._slope = slope_
      self._G     = self._Gr_max
      self._lenc  = t2

    # Store variables in mT - ms
    self.lenc  = 1.0e+3*self._lenc    # [ms]
    self.G     = 1.0e+3*self._G       # [mT/m]
    self.slope = 1.0e+3*self._slope   # [ms]
    if self.lenc < 0:
      self.dur_ = 2*(self._slope + self._slope) # [s]
    else:
      self.dur_ = 2*(self._slope + self._lenc + self._slope) # [s]
    self.dur = 1.0e+3*self.dur_ # [ms]

    # Update timings and amplitudes in array
    timings, amplitudes, _ = self.group_timings()
    self.timings = np.concatenate((timings, timings + timings[-1] - timings[0]))
    self.amplitudes = np.concatenate((amplitudes, -amplitudes))

    # Re-define interpolator
    self.interpolator = interp1d(self.timings, self.amplitudes, kind='linear', fill_value=0.0, bounds_error=False)

  def area(self):
    ''' Calculate the area of the gradient '''
    # Calculate area
    if self.lenc <= 0:
      area = self._G*self._slope
    else:
      area = self._G*self._slope + self._G*self._lenc

    return area

  def match_area(self, area):
    # # Gradient area without rectangle part
    # current_area = self._G*self._slope

    # if current_area < area:
    #   # Add required rectangle area
    #   req_area = area - current_area
    #   self._lenc = req_area/self._G
    # # else:
    # #   # Remove remaining triangle area
    # #   self._G = area/self.slope
    # #   slope_req_ = area/self._G

    # Minimun slope posible to achieve tha maximun gradient amplitude
    slope_min_ = self._Gr_max/self._Gr_sr # [s]

    # Gradient area using maximun amplitude and slewrate (if lenc = 0, area = G*slope)
    area_max_ = slope_min_*self._Gr_max

    # Check if rectangle parts of the gradient are needed
    if area <= area_max_:
      # Calculate needed gradient amplitude
      ratio = area/area_max_
      self._slope = slope_min_*np.sqrt(ratio)
      self._G     = self._Gr_max*np.sqrt(ratio)
      self._lenc  = self._slope - slope_min_*np.sqrt(ratio) 
    else:
      # Calculate missing area needed
      area_needed = area - area_max_

      # Estimate remaining area 
      # If lenc != 0:
      #     area = area_ramps + Gmax*lenc
      # Gradients parameters
      self._slope = slope_min_
      self._G     = self._Gr_max
      self._lenc  = area_needed/self._Gr_max

    # Store variables in mT - ms
    self.lenc  = 1.0e+3*self._lenc    # [ms]
    self.G     = 1.0e+3*self._G       # [mT/m]
    self.slope = 1.0e+3*self._slope   # [ms]
    if self.lenc < 0:
      self.dur_ = 2*self._slope # [s]
    else:
      self.dur_ = 2*self._slope + self._lenc # [s]
    self.dur = 1.0e+3*self.dur_ # [ms]

    # Update timings and amplitudes in array
    self.timings, self.amplitudes, self.interpolator = self.group_timings()

  def plot(self, linestyle='-', axes=[]):
    ''' Plot gradient '''
    fig = plt.figure(2)
    plt.plot(self.timings, self.amplitudes, linestyle)
    plt.show()

    return fig


# Generic tracjectory
class Trajectory:
  def __init__(self, FOV=np.array([0.3, 0.3, 0.08]), res=np.array([100, 100, 1]), oversampling=2, Gr_max=30, Gr_sr=195, lines_per_shot=7, gammabar=42.58, G_enc=Gradient(Gr_max=0, slope=0, lenc=0), receiver_bw=128.0e+3, plot_seq=False, MPS_ori=np.eye(3), LOC=0.0):
    self.FOV = FOV
    self.res = res
    self.oversampling = oversampling
    self.oversampling_arr = np.array([oversampling, 1.0, 1.0])
    self.Gr_max = Gr_max          # [mT/m]
    self._Gr_max = 1.0e-3*Gr_max  # [T/m]
    self.Gr_sr  = Gr_sr           # [mT/(m*ms)]
    self._Gr_sr = Gr_sr           # [T/(m*s)]
    self.gammabar = gammabar                # [MHz/T]
    self._gammabar = 1e+6*gammabar          # [Hz/T]
    self._gamma = 2*np.pi*1e+6*gammabar     # [rad/T]
    self.lines_per_shot = lines_per_shot
    self.ro_samples = self.oversampling * self.res[0] # number of readout samples
    self.ph_samples = self.check_ph_enc_lines(self.res[1])
    self.slices = self.res[2]                  # number of slices
    self.pxsz = FOV / res
    self.k_bw = 1.0 / self.pxsz
    self.k_spa = 1.0 / (self.oversampling_arr * FOV)
    self.kx_extent = (np.array([0, self.ro_samples - 1]) - self.ro_samples // 2) * self.k_spa[0] + (self.res[0] % 2 != 0) * self.k_spa[0]
    self.ky_extent = (np.array([0, self.ph_samples - 1]) - self.ph_samples // 2) * self.k_spa[1]
    self.kz_extent = (np.array([0, self.slices - 1]) - self.slices // 2) * self.k_spa[2]
    self.G_enc = G_enc
    self.plot_seq = plot_seq
    self.receiver_bw = receiver_bw          # [Hz]
    self.MPS_ori = MPS_ori  # orientation
    self.LOC = LOC          # location

  def check_ph_enc_lines(self, ph_samples):
    ''' Verify if the number of lines in the phase encoding direction
    satisfies the multishot factor '''
    lps = self.lines_per_shot
    if ph_samples % lps != 0:
      ph_samples = int(lps * np.floor(ph_samples / lps)) 
    return ph_samples


# Cartesian trajectory
class Cartesian(Trajectory):
    def __init__(self, *args, **kwargs):
      super().__init__(*args, **kwargs)
      self.ph_samples = self.check_ph_enc_lines(self.res[1])
      self.nb_shots = self.ph_samples // self.lines_per_shot
      (self.points, self.times) = self.kspace_points()
      # Send the information to each process if running in parallel
      (self.local_points, self.local_times, self.local_idx) = scatterKspace(self.points, self.times)

    def kspace_points(self):
      ''' Get kspace points '''
      # Gradient duration is not used because can be shorter than second half of the slice selection gradient
      enc_time = self.G_enc.timings[-1]   # ms

      # k-space positioning gradients
      ph_grad = Gradient(t_ref=enc_time, Gr_max=self.Gr_max, Gr_sr=self.Gr_sr)
      ph_grad.calculate(0.5*self.k_bw[1])

      ro_grad0 = Gradient(t_ref=enc_time, Gr_max=self.Gr_max, Gr_sr=self.Gr_sr)
      ro_grad0.calculate(-0.5*self.k_bw[0] - 0.5*ro_grad0._gammabar*ro_grad0._G*ro_grad0._slope)

      blip_grad = Gradient(t_ref=0.0, Gr_max=self.Gr_max, Gr_sr=self.Gr_sr)
      blip_grad.calculate(-self.k_bw[1]/self.ph_samples)

      ro_gradients = [self.G_enc, ro_grad0, ]
      ph_gradients = [ph_grad, ]
      for i in range(self.lines_per_shot):
        # Calculate readout gradient
        ro_grad = Gradient(t_ref=ro_gradients[i+1].timings[-1], Gr_max=self.Gr_max, Gr_sr=self.Gr_sr)
        ro_grad.calculate((-1)**i*self.k_bw[0], receiver_bw=self.receiver_bw, ro_samples=self.ro_samples, ofac=self.oversampling)
        ro_gradients.append(ro_grad)

        # Calculate blip gradient
        ref = ro_gradients[-1].t_ref + ro_gradients[-1].dur - 0.5*blip_grad.dur
        blip_grad = Gradient(t_ref=ref, Gr_max=self.Gr_max, Gr_sr=self.Gr_sr)
        blip_grad.calculate(-self.lines_per_shot*self.k_bw[1]/self.ph_samples)
        ph_gradients.append(blip_grad)

      if self.plot_seq:
        if MPI_rank == 0:
          plt.rcParams['text.usetex'] = True
          fig = plt.figure(figsize=(8,3))
          for gr in ph_gradients[:-1]:
            ax1 = plt.plot(gr.timings, gr.amplitudes, 'r-', linewidth=2)
          for gr in ro_gradients:
            ax2 = plt.plot(gr.timings, gr.amplitudes, 'b-', linewidth=2)
          for i in range(2, self.lines_per_shot+2):
            a = [ro_gradients[i].t_ref + ro_gradients[i].slope,
                ro_gradients[i].t_ref + ro_gradients[i].slope + ro_gradients[i].lenc]
            ax3 = plt.plot(a, [0, 0], 'm:', linewidth=2)
          plt.tick_params('both', length=5, width=1, which='major', labelsize=16)
          plt.tick_params('both', length=3, width=1, which='minor', labelsize=16)
          plt.minorticks_on()
          plt.xlabel('$t~\mathrm{(ms)}$', fontsize=20)
          plt.ylabel('$G~\mathrm{(mT/m)}$', fontsize=20)
          ax1[0].set_label('PH')
          ax2[0].set_label('RO')
          ax3[0].set_label('ADC')
          plt.legend(fontsize=14, loc='upper right', ncols=3)
          plt.axis([0, ro_gradients[-1].t_ref + ro_gradients[-1].dur, -1.4*self.Gr_max, 1.4*self.Gr_max])
          plt.yticks([-40, -20, 0, 20, 40])
          plt.tight_layout()
          plt.show()

      # Time needed to acquire one line
      # It depends on the kspcae bandwidth, the gyromagnetic constant, and
      # the maximun gradient amplitude
      dt = np.linspace(0.0, ro_grad._lenc, self.ro_samples)

      # kspace locations
      kx = np.linspace(self.kx_extent[0], self.kx_extent[1], self.ro_samples)
      ky = self.ky_extent[0]*np.ones(kx.shape)
      kz = np.linspace(self.kz_extent[0], self.kz_extent[1], self.slices)

      kspace = (np.zeros([self.ro_samples, self.ph_samples, self.slices],     
                dtype=np.float32),
                np.zeros([self.ro_samples, self.ph_samples, self.slices],dtype=np.float32),
                np.zeros([self.ro_samples, self.ph_samples, self.slices],dtype=np.float32))

      # kspace times and locations
      t = np.zeros([self.ro_samples, self.ph_samples], dtype=np.float32)
      for ph in range(self.ph_samples):

        # Evaluate readout direction
        if ph % self.lines_per_shot == 0:
          ro = 1

        # Fill locations
        kspace[0][::ro,ph,:] = np.tile(kx[:,np.newaxis], [1, self.slices])
        kspace[1][::ro,ph,:] = np.tile(ky[:,np.newaxis] + self.k_spa[1]*ph, [1, self.slices])

        # Update timings
        if ph % self.lines_per_shot == 0:
          t[::ro,ph] = enc_time/1000.0 + ro_grad0.dur_ + ro_grad._slope + dt
        else:
          t[::ro,ph] = t[:,ph-1].max() + ro_grad._slope + ro_grad._slope + dt[::ro]

        # Reverse readout
        ro = -ro

      # Fill kz coordinates
      for s in range(self.slices):
        kspace[2][:,:,s] = kz[s]

      # Calculate echo time
      self.echo_time = enc_time/1000.0 + ro_grad0.dur_ + 0.5*self.lines_per_shot*ro_grad.dur_

      return (kspace, t)

    def plot_trajectory(self):
      ''' Show kspace points and time map'''
      if MPI_rank == 0:
        # Plot kspace locations and times
        fig, ax = plt.subplots(1, 2, figsize=(12, 5))
        for i in range(int(self.points[0].shape[1]/self.lines_per_shot)):
          idx = [i*self.lines_per_shot, (i+1)*self.lines_per_shot]
          kxx = np.concatenate((np.array([0]), self.points[0][:,idx[0]:idx[1],0].flatten('F')))
          kyy = np.concatenate((np.array([0]), self.points[1][:,idx[0]:idx[1],0].flatten('F')))
          ax[0].plot(kxx,kyy)
        ax[0].set_xlabel('$k_x ~(1/m)$')
        ax[0].set_ylabel('$k_y ~(1/m)$')
        ax[0].axis('equal')

        im = ax[1].scatter(self.points[0][:,:,0],self.points[1][:,:,0],c=1000*self.times,s=2.5,cmap='Greys')
        ax[1].set_xlabel('$k_x ~(1/m)$')
        ax[1].set_ylabel('$k_y ~(1/m)$')
        cbar = fig.colorbar(im, orientation='vertical')
        cbar.ax.tick_params(labelsize=8) 
        cbar.ax.set_title('Time [ms]',fontsize=8)
        ax[1].axis('equal')
        plt.show()


# Radial trajectory
class Radial(Trajectory):
    def __init__(self, *args, spokes=20, **kwargs):
      super().__init__(*args, **kwargs)
      self.spokes = self.check_ph_enc_lines(spokes)
      (self.points, self.times) = self.kspace_points()

    def kspace_points(self):
      ''' Get kspace points '''
      # Time needed to acquire one line
      dt_line = (self.k_bw[0]*2*np.pi)/(self._gamma*self._Gr_max)
      dt = np.linspace(0.0, dt_line, self.ro_samples)

      # kspace locations
      kx = np.linspace(-0.5*self.k_bw[0], 0.5*self.k_bw[0], self.ro_samples)
      ky = np.zeros(kx.shape)
      kspace = (np.zeros([self.ro_samples, self.spokes]),
                np.zeros([self.ro_samples, self.spokes]))

      # Angles for each ray
      theta = np.linspace(0, np.pi, self.spokes+1)
      theta = theta[0:-1]

      # kspace times and locations
      t = np.zeros([self.ro_samples, self.spokes])
      for sp in range(0, self.spokes):
        # Rotation matrix
        if (sp+1) % 2 != 0:
          kspace[0][:,sp] = kx*np.cos(theta[sp]) + ky*np.sin(theta[sp])
          kspace[1][:,sp] = -kx*np.sin(theta[sp]) + ky*np.cos(theta[sp])
        else:
          kspace[0][::-1,sp] = kx*np.cos(theta[sp]) + ky*np.sin(theta[sp])
          kspace[1][::-1,sp] = -kx*np.sin(theta[sp]) + ky*np.cos(theta[sp])

        if sp % self.lines_per_shot == 0:
          t[:,sp] = dt
        else:
          t[:,sp] = t[-1,sp-1] + dt

      # Send the information to each process if running in parallel
      kspace, t, local_idx = scatterKspace(kspace, t)
      self.local_idx = local_idx

      return (kspace, t)

    def plot_trajectory(self):
      ''' Show kspace points '''
      # Plot kspace locations and times
      fig, axs = plt.subplots(1, 2, figsize=(10, 5))
      axs[0].plot(self.points[0].flatten('F'),self.points[1].flatten('F'))
      im = axs[1].scatter(self.points[0],self.points[1],c=1000*self.times,s=1.5)
      axs[0].set_xlabel('k_x (1/m)')
      axs[0].set_ylabel('k_y (1/m)')
      axs[1].set_xlabel('k_x (1/m)')
      axs[1].set_ylabel('k_y (1/m)')
      cbar = fig.colorbar(im, ax=axs[1])
      cbar.ax.tick_params(labelsize=8) 
      cbar.ax.set_title('Time [ms]',fontsize=8)
      plt.show()


# Spiral trajectory
class Spiral(Trajectory):
    def __init__(self, *args, interleaves=20, parameters=[], **kwargs):
      super().__init__(*args, **kwargs)
      self.interleaves = self.check_ph_enc_lines(interleaves)
      self.parameters = parameters
      (self.points, self.times) = self.kspace_points()

    def kspace_points(self):
      ''' Get kspace points '''
      # Spiral parameters
      N = self.interleaves        # Number of interleaves
      f = self.FOV[0]             # Field-of-view
      k0 = self.parameters['k0']
      k1 = self.parameters['k1']
      S = self.parameters['Slew-rate']    # Slew-rate [T/m/s]
      gamma = self.gamma
      r = self.pxsz[0]

      # Radial distance definition
      kr0 = k0*0.5*self.k_bw[0]
      kr1 = k1*0.5*self.k_bw[0]
      kr = np.linspace(0, 1, self.ro_samples)
      kr = kr1*(kr**1)
      phi = 2*np.pi*f*kr/N

      # Complex trajectory
      K = kr*np.exp(1j*phi)

      # Time needed to acquire one interleave
      t_sc = np.sqrt(2)*np.pi*f/(3*N*np.sqrt(1e+6*gamma*1e-3*S)*r**(3/2))
      dt = np.linspace(0.0, t_sc, self.ro_samples)    

      # kspace locations
      kx = np.real(K)
      ky = np.imag(K)
      kspace = (np.zeros([self.ro_samples, self.interleaves]),
                np.zeros([self.ro_samples, self.interleaves]))

      # Angles for each ray
      theta = np.linspace(0, 2*np.pi, self.interleaves+1)
      theta = theta[0:-1]

      # kspace times and locations
      t = np.zeros([self.ro_samples, self.interleaves])
      for sp in range(0, self.interleaves):
        # Rotation matrix
        kspace[0][:,sp] = kx*np.cos(theta[sp]) + ky*np.sin(theta[sp])
        kspace[1][:,sp] = -kx*np.sin(theta[sp]) + ky*np.cos(theta[sp])

        if sp % self.lines_per_shot == 0:
          t[:,sp] = dt
        else:
          t[:,sp] = t[-1,sp-1] + dt

      # Send the information to each process if running in parallel
      kspace, t, local_idx = scatterKspace(kspace, t)
      self.local_idx = local_idx

      return (kspace, t)

    def plot_trajectory(self):
      ''' Show kspace points '''
      # Plot kspace locations and times
      fig, axs = plt.subplots(1, 2, figsize=(10, 5))
      axs[0].plot(self.points[0].flatten('F'),self.points[1].flatten('F'))
      im = axs[1].scatter(self.points[0],self.points[1],c=1000*self.times,s=1.5)
      axs[0].set_xlabel('k_x (1/m)')
      axs[0].set_ylabel('k_y (1/m)')
      axs[1].set_xlabel('k_x (1/m)')
      axs[1].set_ylabel('k_y (1/m)')
      cbar = fig.colorbar(im, ax=axs[1])
      cbar.ax.tick_params(labelsize=8) 
      cbar.ax.set_title('Time [ms]',fontsize=8)
      plt.show()


def SpiralCalculator():
  return True
